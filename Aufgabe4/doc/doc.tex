\documentclass{scrreprt}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage {ngerman}
\usepackage{fancyvrb}
\usepackage{xcolor}

\author {Team "`Herder"' -- Robert Clausecker}
\title {L"osung zur Aufgabe 4}
\subtitle {des 29. Bundeswettbewerbs Informatik}

%Definitionen für den Formatierer
\include{definitions}

\begin{document}
\maketitle

\tableofcontents \newpage

\chapter{L"osungsverfahren}
Zur L"osung der Aufgabe wurde die funkionale Programmiersprache \emph{Haskell}
verwandt. Aufgrund der speziellen Eigenschaften von Haskell (strikte
Typisierung, Faulheit, sehr gro"se Standardbibliothek, etc.) halte ich diese 
Sprache vorallem f"ur solche mathematische Probleme geignet.

\section{Algorithmus}
Der Grundgedanke der L"osung ist es, das Spiel komplett zu "`l"osen"', also f"ur
jeden m"oglichen Zustand den Erwartungswert zu berechnen.  Diese Erwartungswerte
werden rekursiv berechnet.

Dazu wird f"ur alle m"oglichen Augenzahlen erechnet, welche M"oglichkeiten es
gibt, Karten auszuw"ahlen und welche von diesen den h"ochsten Erwartungswert
besitzt.  Der Erwartungswert der besten Auswahl wird anschlie"send mit der
Wahrscheinlichkeit der Augenzahl multipliziert und mit den anderen
Erwartungswerten nach Augenzahlen aufsummiert.

Im Spielmodus zieht der Computer stets den Zug, der den h"ochsten Erwartungswert
hat.  Nach vielen Spielen sollte sich das Ergebnis dem berechneten Resultat
angleichen.

\section{Caching}
Aufgrund der Tatsache, dass der Spielbaum recht gro"s ist, dauert es eine Weile,
ein aufwendiges Spiel zu analysieren.  Da es jedoch nur insgesamt 512 m"ogliche
Spielst"ande gibt (Jede Karte kann entweder auf- oder zugedeckt sein; also $2^9
= 512$ M"oglichkeiten), und der Erwartungswert eines Spielstandes unabh"angig
von vorherigen Z"ugen ist, liegt es nahe, die Ergebnisse in geeigneter Form
zwischenzuspeichern.

Der Zwischenspeicher ist in diesem Fall als Array umgesetzt, dass einfach alle
m"oglichen Spielst"ande als Indizes gegen die Erwartungswerte stellt.  Die Werte
im Array werden von den richtigen statistischen Funktionen berechnet, anstatt
sich jedoch rekursiv aufzurufen greifen sie einfach auf den Cache zu.  Weil
Haskell nun aber die Werte nur bei Bedarf generiert, werden die Elemente des
faulen Arrays eben auch nur bei Bedarg berechnet.  Dies macht die L"osung
einfach, umst"andlicher Code, um zu pr"ufen, ob der Wert schon berechnet wurde,
entf"allt, weil bereits im Laufzeitsystem eingebaut.

\chapter{Bedienung}
Das Programm l"asst sich in verschiedenen Modi starten.  Man kann sowohl einen
bestimmten Spielstand analysieren, als auch interaktiv gegen den Computer
spielen und sich eventuell helfen lassen.  Alle verf"ugbaren Modi werden im
folgenden erkl"art.

\section{Überblick}
Es folgt eine Auflistung der Betriebsmodi und weiterer Parameter.  Generell
werden Parameter, die keinen Sinn ergeben ignoriert.  Sollten wiederspr"uchliche
Parameter gegeben sein, so ist nur der jeweils letzte relevant.\footnote{Weitere
Parameter sind verf"ugbar, rufen Sie das Programm mit dem Schalter \texttt
{-\-help} f"ur weitere Informationen auf.}

\begin{description}
\item[-\,-\,help] Zeigt eine \emph{kurze Erl"auterung} der verf"ugbaren
  Parameter an.  Ich gehe in der Dokumentation nicht n"aher auf diesen Befehl
  ein, da er trivial ist.
\item[-\,-\,analyze] F"uhrt eine \emph{Analyse} eines Spielstandes aus.  Falls
  der Spielstand nicht per Parameter "ubergeben wird, so wird der Anfangszustand
  (also keine Karte umgedreht) verwendet.
\item[-\,-\,auto] L"asst den Computer eine beliebige Anzahl an Spielen \emph
  {gegen sich selbst} spielen.  Die Ergebnisse werden gesammelt und ausgegeben.
\item[-\,s \textit{x}] Setzt den zu verwendenden Spielstand auf \textit{x}.  Der
  Spielstand kann wahlweise auch ohne vorangestelltes \texttt{-s} gesetzt
  werden.
\item[-\,n \textit{x}] Setzt die Anzahl der Spiele, die der Computer gegen sich
  selbst spielt auf \textit{x}.
\item[-\,v] Gebe mehr Informationen aus.  Mehrfache Angabe des Parameters
  \texttt{-v} gibt noch mehr Informationen aus.\footnote{Diese Funktion ist
  haupts"achlich zur Fehlersuche gedacht unf funktioniert nicht fehlerfrei.}
\end{description}
Die Argumente werden generell erst dann auf Fehler gepr"uft, wenn sie auch
wirklich verwendet werden.  Dies steht v"ollig im Einklang mit dem Prinzip der
Faulheit (\emph{laziness}) von Haskell.

\section{Analysemodus}
Im Analysemodus wird ein Spielstand analysiert und Erwartungswerte ausgegeben.
Die Erwartungswerte sind nach W"urfelaugen aufgef"achert.  Zur Kontrolle kann
man den Computer sehr h"aufig gegen sich selbst spielen lassen und die
Ergebnisse vergleichen.

\subsection*{Beispiel}
Das Programm gibt eine Ausgabe in folgendem Format aus. Die erste Zeile gibt den
Erwartungswert aus -- also das zu erwartende Durchschnittsergebnis nach sehr
vielen Spielen.  In den n"achsten Zeilen wird dann nach Augenzahl aufgef"achert.

Aus Platzgr"unden wurde die Ausgabe gek"urzt, Die vollst"andige Ausgabe ist im
Verzeichnis \emph{Beispiele} des Projektordners zu finden.

\begin{verbatim}
$ ./Aufgabe4 -as 123456
Erwartungswert: 37.98033955380277
Details:
  Würfelergebnis  2
Erwartungswert: 37.50278277892089
Kandidaten:
    Auswahl 2,    Erwartung 37.50278277892089
... usw ...
\end{verbatim}

\section{Automatischer Modus}
Dieser Modus wird durch die Angabe des Parameters \texttt{-\/-auto} aktiviert.
Der Computer spielt eine Folge von Spielen gegen sich selbst, die Ergebnisse
werden gesammelt und als "ubersichtliche Statistik ausgegeben.  Die gew"urfelten
Zahlen werden vom Zufallsgenerator des Systems bestimmt, somit ist die Ausgabe
des Programms bei jedem Lauf mit hoher Wahrscheinlichkeit unterschiedlich.

Das durchschnittliche Ergebnis nach vielen (c.\,a. 10000) Spielen sollte der
Ausgabe der Analysefunktion "ahneln und kann als Kontrolle verwendet werden.

\subsection*{Beispiel}
Im folgenden Beispiel wurden 250 Spiele gegen den Computer gespielt.  Um Papier
zu sparen, ist die Ausgabe gek"urzt, die vollst"andige Ausgabe ist im Ordner
\emph{Beispiele} des Projektverzeichnises zu finden.

\begin{verbatim}
$ ./Aufgabe4 -cn 250 -s 12345

Statistik aus 250 Spielen:
Durchschnittliches Ergebnis: 33.24799999999997
Verteilung der Ergebnisse:
	 2:     1 (0.40%)
	10:     2 (0.80%)
	12:     1 (0.40%)
    ... usw.
\end{verbatim}

\chapter{Quelltexte}

\section{Aufgabe4/Datentypen.hs}
\input{Datentypen.hs}

\section{Aufgabe4/Statistik.hs}
\input{Statistik.hs}

\section{Aufgabe4/IO.hs}
\input{IO.hs}

\section{Main.hs}
\input{Main.hs}

\end{document}
